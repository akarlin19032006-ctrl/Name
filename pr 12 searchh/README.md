1)Сортировка выбором (Selection Sort) — на каждом шаге алгоритма находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве.
*  Объяснение работы алгоритма:
Во внешнем цикле выбирается первый элемент массива и считается, что он минимальный.
•Затем начинается внутренний цикл, который ищет реальный минимальный элемент среди остальных.
•Найдя этот элемент, алгоритм меняет его местами с первым элементом текущего прохода.
•Процесс продолжается до тех пор, пока весь массив не будет отсортирован.
Временная сложность:
Лучший случай: O(n²) - массив уже отсортирован
Худший случай: O(n²) - массив отсортирован в обратном порядке
Средний случай: O(n²)
Почему:
Временная сложность O(n²) потому, что алгоритм выполняет примерно n²/2 сравнений, и эта квадратичная зависимость сохраняется для любых входных данных.

2)Сортировка обменом (пузырьком) (Bubble Sort) — алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.
Объяснение работы алгоритма:
Проход по массиву сверху вниз. Начиная с первых двух элементов, сравниваем их друг с другом:
•Если первый элемент больше второго, они меняются местами.
•Продолжаем сравнивать пару соседних элементов дальше по массиву, двигаясь вправо.
Каждый полный проход поднимает («всплывает») самое большое значение наверх. Например, после первого полного прохода последний элемент массива гарантированно становится максимальным.
Процесс повторяется. Следующие шаги работают аналогичным образом, но теперь верхний элемент уже занимает свое место и его не трогают. Так, на втором полном проходе второе с конца место займет второй по величине элемент, и так далее.
Продолжаем повторять процедуру до тех пор, пока весь массив не будет отсортирован.
Временная сложность:O(n²)
Почему:
Временная сложность O(n²) потому, что алгоритм выполняет примерно n²/2 сравнений в худшем и среднем случае. Квадратичная зависимость возникает из-за вложенных циклов, где внутренний цикл уменьшается линейно, что в сумме дает квадратичную функцию.

3)Сортировка вставками (Insertion Sort) — алгоритм строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место.
Объяснение работы алгоритма:
Алгоритм работает как сортировка карт в руке - берем каждый следующий элемент и вставляем его в правильную позицию среди уже отсортированных элементов слева.
Пошаговый процесс:
Начинаем со второго элемента (первый считается отсортированным)
Для каждого элемента:
•	Запоминаем его значение (key)
•	Сравниваем с элементами слева (уже отсортированными)
•	Сдвигаем все большие элементы вправо
•	Вставляем элемент на освободившуюся позицию
Временная сложность:O(n²)
Почему:
Внешний цикл: выполняется n-1 раз
Внутренний цикл: в худшем случае выполняется i раз для каждого i
Общее количество операций: 1 + 2 + 3 + ... + (n-1) = n(n-1)/2
Упрощаем: n(n-1)/2 ≈ n²/2 → O(n²)
Квадратичная сложность возникает из-за вложенных циклов, где внутренний цикл в худшем случае делает линейное количество операций для каждого элемента.

4)Сортировка слиянием (Merge Sort) — алгоритм состоит в разделении массива пополам,сортировке половин и их слиянии.
Объяснение работы алгоритма:
Алгоритм использует стратегию "разделяй и властвуй"
Разделение: разбиваем массив пополам до отдельных элементов
Слияние: объединяем отсортированные части в один отсортированный массив
Временная сложность :O(n log n)
Почему:
Рекуррентное соотношение: T(n) = 2T(n/2) + O(n)
•	Разделение: массив делится пополам на каждом уровне рекурсии → log₂n уровней
•	Слияние: на каждом уровне выполняем слияние всех элементов → O(n) операций на уровень
•	Итого: O(n) × O(log n) = O(n log n)
Сортировка слиянием всегда работает за O(n log n), так как независимо от исходных данных выполняет полное разделение и слияние.

5) Сортировка Шелла(Shell sort)  - это улучшенная версия сортировки вставками. Алгоритм сортирует элементы, находящиеся на определенном расстоянии друг от друга, постепенно уменьшая это расстояние.
Объяснение работы алгоритма:
1.	Выбор промежутка (gap): Начинаем с большого промежутка (обычно n/2)
2.	Сортировка подмассивов: Сортируем элементы, отстоящие друг от друга на gap
3.	Уменьшение промежутка: Постепенно уменьшаем gap до 1
4.	Финальная сортировка: При gap=1 выполняем обычную сортировку вставками
Временная сложность :
•	Худший случай: O(n²) - при плохой последовательности промежутков
•	Средний случай: O(n log²n) или O(n^(3/2)) - при хорошей последовательности
•	Лучший случай: O(n log n) - когда массив уже частично отсортирован
Почему:
•	Алгоритм выполняет несколько проходов с разными промежутками
•	Каждый проход частично сортирует массив, делая его "более упорядоченным"
•	Финальный проход (gap=1) работает быстрее, так как массив уже почти отсорти-рован
•	Эффективность зависит от последовательности gap - разные последовательности дают разную сложность

6)Быстрая сортировка (Quick Sort) — один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента,вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них.
Объяснение работы алгоритма:
1.	Выбор опорного элемента (pivot)
2.	Разделение: перераспределение элементов так, чтобы меньшие оказались слева, большие - справа
3.	Рекурсия: применение алгоритма к подмассивам слева и справа
Временная сложность :
Средний случай: O(n log n)
Худший случай: O(n²)
Лучший случай: O(n log n)
Почему:
Быстрая сортировка в среднем случае работает за O(n log n), но может деградировать до O(n²) при неудачном выборе опорного элемента.

7)Пирамидальная сортировка — алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.
Объяснение работы алгоритма:
Пирамидальная сортировка использует структуру данных "двоичная куча" (binary heap). Алгоритм состоит из двух основных этапов:
1.	Построение max-кучи из неотсортированного массива
2.	Последовательное извлечение максимальных элементов из кучи
Временная сложность: O(n log n)
Почему:
Пирамидальная сортировка гарантирует время O(n log n) в любом случае, так как и построение кучи, и извлечение элементов имеют предсказуемую логарифмическую сложность для каждой операции.

8)Последовательный (линейный) поиск —  это простейший алгоритм поиска, который проверяет каждый элемент массива по очереди до тех пор, пока не найдет искомый элемент или не проверит все элементы. 
Объяснение работы алгоритма:
1.	Начинаем с первого элемента массива
2.	Сравниваем текущий элемент с искомым значением
3.	Если элементы равны - возвращаем индекс текущего элемента
4.	Если не равны - переходим к следующему элементу
5.	Повторяем шаги 2-4 до нахождения элемента или конца массива
6.	Если дошли до конца и не нашли элемент - возвращаем -1
Временная сложность :  O(n)
Почему:
Последовательный поиск имеет линейную сложность O(n), так как в худшем случае алгоритму необходимо проверить каждый из n элементов массива.

9)Бинарный (двоичный, дихотомический) поиск —  это эффективный алгоритм для поиска в отсортированном массиве. Алгоритм постоянно делит область поиска пополам, отбрасывая ту половину, где искомый элемент заведомо не может находиться.
Объяснение работы алгоритма:
1.	Определяем границы поиска (left и right)
2.	Находим средний элемент между границами
3.	Сравниваем средний элемент с искомым:
o	Если равны - поиск завершен
o	Если средний больше - ищем в левой половине
o	Если средний меньше - ищем в правой половине
4.	Повторяем до нахождения элемента или исчерпания области поиска
Временная сложность : O(log n)
Почему:
Бинарный поиск имеет логарифмическую сложность O(log n), потому что на каждом шаге он уменьшает область поиска в два раза. 

10)Интерполирующий поиск — это улучшенная версия бинарного поиска, которая вместо деления области поиска пополам, пытается "угадать" позицию искомого элемента на основе значений границ и искомого элемента.
Объяснение работы алгоритма:
1.	Вычисляем предполагаемую позицию с помощью интерполяционной формулы
2.	Сравниваем элемент на вычисленной позиции с искомым
3.	Если равны - поиск завершен
4.	Если искомый элемент меньше - ищем в левой части
5.	Если искомый элемент больше - ищем в правой части
6.	Повторяем до нахождения элемента или исчерпания области поиска
Временная сложность :
Лучший случай: O(1)
•	Элемент находится точно на вычисленной позиции
Средний случай: O(log log n)
•	При равномерном распределении данных
•	Количество шагов удваивается только при квадратичном увеличении n
Худший случай: O(n)
•	При очень неравномерном распределении данных
•	Элементы сконцентрированы в определенных областя
Почему:
•	На каждом шаге алгоритм значительно уменьшает область поиска
•	При равномерном распределении позиция вычисляется очень точно
•	Количество шагов растет очень медленно с увеличением n
Интерполирующий поиск имеет сложность O(log log n) в среднем случае, потому что при равномерном распределении данных он очень точно предсказывает позицию искомого элемента, что позволяет исключать большие части массива за один шаг.

11)Поиск по Фибоначчи — это алгоритм поиска в отсортированном массиве, который использует числа Фибоначчи для определения позиций сравнения. Алгоритм делит массив на части, пропорциональные числам Фибоначчи.
Объяснение работы алгоритма:
1.	Генерируем числа Фибоначчи до получения числа, большего или равного длине массива
2.	Используем три числа Фибоначчи:
o	F(m) - наименьшее число ≥ n
o	F(m-1) - предыдущее число
o	F(m-2) - предпредыдущее число
3.	Сравниваем элемент на позиции (offset + F(m-2)) с искомым
4.	В зависимости от результата:
o	Если элемент меньше - сдвигаемся вправо
o	Если элемент больше - сдвигаемся влево
o	Если равен - поиск завершен
Временная сложность : O(log n)
Почему:
Поиск Фибоначчи имеет сложность O(log n), так как на каждом шаге он уменьшает область поиска в отношении, близком к золотому сечению, что обеспечивает логарифмическое количество операций.
