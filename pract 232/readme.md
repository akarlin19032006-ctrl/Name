объяснение работы алгоритма:

а) Генерация соседнего решения
random.uniform(-1, 1) - добавляет случайный сдвиг от -1 до +1
max(a, min(b, neighbor)) - ограничивает решение в диапазоне [a, b]

б) Расчет энергии и принятие решения
delta_energy < 0 - если новое решение лучше, всегда принимаем его
math.exp(-delta_energy / temp) - формула вероятности принятия худшего решения
При высокой температуре вероятность принять худшее решение высокая
При низкой температуре алгоритм становится "жадным"

в) Обновление лучшего решения
Всегда сохраняем лучшее найденное решение, даже если временно перешли к худшему.
if current_energy < best_energy:
best_x, best_energy = current, current_energy

г) Охлаждение
Температура уменьшается умножением на 0.99 на каждом шаге.(temp *= alpha)


результат:
Введите начало диапазона: 0
Введите конец диапазона: 20
Найденный минимум: f(7.00000) = 5.00000

временная сложность:O(1)

почему:
Алгоритм имеет постоянную временную сложность O(1), так как выполняет фиксированное количество операций независимо от входных данных.
